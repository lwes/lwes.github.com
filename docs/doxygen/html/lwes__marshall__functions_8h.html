<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>lwes: lwes_marshall_functions.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>lwes_marshall_functions.h File Reference</h1>
<p>Functions for marshalling LWES data types to/from byte arrays.  
<a href="#_details">More...</a></p>

<p><a href="lwes__marshall__functions_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#aab8ccc1f35cf61e316957514f3522923">marshall_BYTE</a> (<a class="el" href="lwes__types_8h.html#ae03ffdbd0aae8db082d8520bf05f7952">LWES_BYTE</a> aByte, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a byte into a byte array.  <a href="#aab8ccc1f35cf61e316957514f3522923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a8014fea1192f64d7166c1b00b752adf6">marshall_U_INT_16</a> (<a class="el" href="lwes__types_8h.html#a39a07a14506fffb6a47cca57abfed182">LWES_U_INT_16</a> anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a 16 bit unsigned int into a byte array.  <a href="#a8014fea1192f64d7166c1b00b752adf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#acd532e5afeb2bd123263abff0c1974c0">marshall_INT_16</a> (<a class="el" href="lwes__types_8h.html#a78b9045303595b0a80edf37fa6f7ac9d">LWES_INT_16</a> anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a 16 bit int into a byte array.  <a href="#acd532e5afeb2bd123263abff0c1974c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a4dbdd14b6863e43185043bed7ca05559">marshall_U_INT_32</a> (<a class="el" href="lwes__types_8h.html#a0171d29ac3e49fea5a001037d67327a1">LWES_U_INT_32</a> anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a 32 bit unsigned int into a byte array.  <a href="#a4dbdd14b6863e43185043bed7ca05559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#aa6f156c10c9667fcdfb4d5a5d5cefdec">marshall_INT_32</a> (<a class="el" href="lwes__types_8h.html#a08f39317c3e23633e355d49c1e68c656">LWES_INT_32</a> anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a 32 bit int into a byte array.  <a href="#aa6f156c10c9667fcdfb4d5a5d5cefdec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#aef87edf5099270f2569f4d75c114ab5a">marshall_U_INT_64</a> (<a class="el" href="lwes__types_8h.html#a7edcf94a675e9f0f0f68769b2d2badcd">LWES_U_INT_64</a> anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a 64 bit unsigned int into a byte array.  <a href="#aef87edf5099270f2569f4d75c114ab5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a325ec0e4ab449ad8d54c6efa3d3cf865">marshall_INT_64</a> (<a class="el" href="lwes__types_8h.html#a136f66144ccf70b54e4bb00efafe9698">LWES_INT_64</a> anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a 64 bit int into a byte array.  <a href="#a325ec0e4ab449ad8d54c6efa3d3cf865"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a04363b34af1ecbf2b68b0afc1d9a44af">marshall_BOOLEAN</a> (<a class="el" href="lwes__types_8h.html#a0c708659725468d2742864fee7f125cf">LWES_BOOLEAN</a> aBoolean, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a boolean into a byte array.  <a href="#a04363b34af1ecbf2b68b0afc1d9a44af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a9ac89647f4f5a84dfd55aa3aaeecdd7f">marshall_IP_ADDR</a> (<a class="el" href="lwes__types_8h.html#afab73e182f5452ab18ceea7665fe7de5">LWES_IP_ADDR</a> ipAddress, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall an ip4v address into a byte array.  <a href="#a9ac89647f4f5a84dfd55aa3aaeecdd7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a2627754805de3cea9b7ee2d7cf415af3">marshall_SHORT_STRING</a> (<a class="el" href="lwes__types_8h.html#ab426e9825a40d378e7ffc13b5a7be906">LWES_SHORT_STRING</a> aString, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a short string into a byte array.  <a href="#a2627754805de3cea9b7ee2d7cf415af3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a0b87ae0639e7c47b6cf5d3639db0dbfc">marshall_LONG_STRING</a> (<a class="el" href="lwes__types_8h.html#a74b6273817a2fd70c98c9c1bed431518">LWES_LONG_STRING</a> aString, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marshall a long string into a byte array.  <a href="#a0b87ae0639e7c47b6cf5d3639db0dbfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#aada4777e52dbff1766508b4e54552a93">unmarshall_BYTE</a> (<a class="el" href="lwes__types_8h.html#ae03ffdbd0aae8db082d8520bf05f7952">LWES_BYTE</a> *aByte, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a byte from a byte array.  <a href="#aada4777e52dbff1766508b4e54552a93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#aea0f68c9e3c6885ffc3f443391306dd5">unmarshall_U_INT_16</a> (<a class="el" href="lwes__types_8h.html#a39a07a14506fffb6a47cca57abfed182">LWES_U_INT_16</a> *anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a 16 bit unsigned int from a byte array.  <a href="#aea0f68c9e3c6885ffc3f443391306dd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a9c413aff9b923f517ad0d6476b0935ac">unmarshall_INT_16</a> (<a class="el" href="lwes__types_8h.html#a78b9045303595b0a80edf37fa6f7ac9d">LWES_INT_16</a> *anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a 16 bit int from a byte array.  <a href="#a9c413aff9b923f517ad0d6476b0935ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a423d499469ea32a8c683c1d1609e902e">unmarshall_U_INT_32</a> (<a class="el" href="lwes__types_8h.html#a0171d29ac3e49fea5a001037d67327a1">LWES_U_INT_32</a> *anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a 32 bit unsigned int from a byte array.  <a href="#a423d499469ea32a8c683c1d1609e902e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#aedb853f7265bc58686a247b0472f88a9">unmarshall_INT_32</a> (<a class="el" href="lwes__types_8h.html#a08f39317c3e23633e355d49c1e68c656">LWES_INT_32</a> *anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a 32 bit int from a byte array.  <a href="#aedb853f7265bc58686a247b0472f88a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a8baecf644673e61dcdeb6ec4274b98dc">unmarshall_U_INT_64</a> (<a class="el" href="lwes__types_8h.html#a7edcf94a675e9f0f0f68769b2d2badcd">LWES_U_INT_64</a> *anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a 64 bit unsigned int from a byte array.  <a href="#a8baecf644673e61dcdeb6ec4274b98dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a145eeb7199a6987e1c8d250ebad8b0a8">unmarshall_INT_64</a> (<a class="el" href="lwes__types_8h.html#a136f66144ccf70b54e4bb00efafe9698">LWES_INT_64</a> *anInt, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a 64 bit int from a byte array.  <a href="#a145eeb7199a6987e1c8d250ebad8b0a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a23199100ec118beb30bec07d3f098c55">unmarshall_BOOLEAN</a> (<a class="el" href="lwes__types_8h.html#a0c708659725468d2742864fee7f125cf">LWES_BOOLEAN</a> *aBoolean, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a boolean from a byte array.  <a href="#a23199100ec118beb30bec07d3f098c55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#afcdee1b06232f1f3b3802d13dc6d6c36">unmarshall_IP_ADDR</a> (<a class="el" href="lwes__types_8h.html#afab73e182f5452ab18ceea7665fe7de5">LWES_IP_ADDR</a> *ipAddress, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall an ipv4 address from a byte array.  <a href="#afcdee1b06232f1f3b3802d13dc6d6c36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a6971c3b3ae06c8fee8945f1bc2736f92">unmarshall_SHORT_STRING</a> (<a class="el" href="lwes__types_8h.html#ab426e9825a40d378e7ffc13b5a7be906">LWES_SHORT_STRING</a> aString, size_t max_string_length, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a short string from a byte array.  <a href="#a6971c3b3ae06c8fee8945f1bc2736f92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lwes__marshall__functions_8h.html#a51593ae7aaaed7ad63f5724dbe7aec6f">unmarshall_LONG_STRING</a> (<a class="el" href="lwes__types_8h.html#a74b6273817a2fd70c98c9c1bed431518">LWES_LONG_STRING</a> aString, size_t max_string_length, <a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a> bytes, size_t length, size_t *offset)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarshall a long string from a byte array.  <a href="#a51593ae7aaaed7ad63f5724dbe7aec6f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions for marshalling LWES data types to/from byte arrays. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aab8ccc1f35cf61e316957514f3522923"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_BYTE" ref="aab8ccc1f35cf61e316957514f3522923" args="(LWES_BYTE aByte, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_BYTE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#ae03ffdbd0aae8db082d8520bf05f7952">LWES_BYTE</a>&nbsp;</td>
          <td class="paramname"> <em>aByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a byte into a byte array. </p>
<p>Attempt to marshall aByte into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aByte</em>&nbsp;</td><td>the byte to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a8014fea1192f64d7166c1b00b752adf6"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_U_INT_16" ref="a8014fea1192f64d7166c1b00b752adf6" args="(LWES_U_INT_16 anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_U_INT_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a39a07a14506fffb6a47cca57abfed182">LWES_U_INT_16</a>&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a 16 bit unsigned int into a byte array. </p>
<p>Attempt to marshall anInt into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_U_INT_16 to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="acd532e5afeb2bd123263abff0c1974c0"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_INT_16" ref="acd532e5afeb2bd123263abff0c1974c0" args="(LWES_INT_16 anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_INT_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a78b9045303595b0a80edf37fa6f7ac9d">LWES_INT_16</a>&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a 16 bit int into a byte array. </p>
<p>Attempt to marshall anInt into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_INT_16 to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dbdd14b6863e43185043bed7ca05559"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_U_INT_32" ref="a4dbdd14b6863e43185043bed7ca05559" args="(LWES_U_INT_32 anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_U_INT_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a0171d29ac3e49fea5a001037d67327a1">LWES_U_INT_32</a>&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a 32 bit unsigned int into a byte array. </p>
<p>Attempt to marshall anInt into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_U_INT_32 to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6f156c10c9667fcdfb4d5a5d5cefdec"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_INT_32" ref="aa6f156c10c9667fcdfb4d5a5d5cefdec" args="(LWES_INT_32 anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_INT_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a08f39317c3e23633e355d49c1e68c656">LWES_INT_32</a>&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a 32 bit int into a byte array. </p>
<p>Attempt to marshall anInt into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_INT_32 to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aef87edf5099270f2569f4d75c114ab5a"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_U_INT_64" ref="aef87edf5099270f2569f4d75c114ab5a" args="(LWES_U_INT_64 anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_U_INT_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a7edcf94a675e9f0f0f68769b2d2badcd">LWES_U_INT_64</a>&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a 64 bit unsigned int into a byte array. </p>
<p>Attempt to marshall anInt into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_U_INT_64 to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a325ec0e4ab449ad8d54c6efa3d3cf865"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_INT_64" ref="a325ec0e4ab449ad8d54c6efa3d3cf865" args="(LWES_INT_64 anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_INT_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a136f66144ccf70b54e4bb00efafe9698">LWES_INT_64</a>&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a 64 bit int into a byte array. </p>
<p>Attempt to marshall anInt into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_INT_64 to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a04363b34af1ecbf2b68b0afc1d9a44af"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_BOOLEAN" ref="a04363b34af1ecbf2b68b0afc1d9a44af" args="(LWES_BOOLEAN aBoolean, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_BOOLEAN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a0c708659725468d2742864fee7f125cf">LWES_BOOLEAN</a>&nbsp;</td>
          <td class="paramname"> <em>aBoolean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a boolean into a byte array. </p>
<p>Attempt to marshall aBoolean into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aBoolean</em>&nbsp;</td><td>the LWES_BOOLEAN to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ac89647f4f5a84dfd55aa3aaeecdd7f"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_IP_ADDR" ref="a9ac89647f4f5a84dfd55aa3aaeecdd7f" args="(LWES_IP_ADDR ipAddress, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_IP_ADDR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#afab73e182f5452ab18ceea7665fe7de5">LWES_IP_ADDR</a>&nbsp;</td>
          <td class="paramname"> <em>ipAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall an ip4v address into a byte array. </p>
<p>Attempt to marshall ipAddress into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipAddress</em>&nbsp;</td><td>the LWES_IP_ADDR to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a2627754805de3cea9b7ee2d7cf415af3"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_SHORT_STRING" ref="a2627754805de3cea9b7ee2d7cf415af3" args="(LWES_SHORT_STRING aString, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_SHORT_STRING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#ab426e9825a40d378e7ffc13b5a7be906">LWES_SHORT_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>aString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a short string into a byte array. </p>
<p>Attempt to marshall aString into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aString</em>&nbsp;</td><td>the LWES_SHORT_STRING to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b87ae0639e7c47b6cf5d3639db0dbfc"></a><!-- doxytag: member="lwes_marshall_functions.h::marshall_LONG_STRING" ref="a0b87ae0639e7c47b6cf5d3639db0dbfc" args="(LWES_LONG_STRING aString, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int marshall_LONG_STRING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a74b6273817a2fd70c98c9c1bed431518">LWES_LONG_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>aString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshall a long string into a byte array. </p>
<p>Attempt to marshall aString into the given byte array at the given offset if there is enough total space. The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes set, and that value will be returned. Thus a value of 0 is an error, meaning not enough space to write this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aString</em>&nbsp;</td><td>the LWES_LONG_STRING to write into the array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes written on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aada4777e52dbff1766508b4e54552a93"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_BYTE" ref="aada4777e52dbff1766508b4e54552a93" args="(LWES_BYTE *aByte, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_BYTE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#ae03ffdbd0aae8db082d8520bf05f7952">LWES_BYTE</a> *&nbsp;</td>
          <td class="paramname"> <em>aByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a byte from a byte array. </p>
<p>Attempt to unmarshall aByte from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aByte</em>&nbsp;</td><td>the byte to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aea0f68c9e3c6885ffc3f443391306dd5"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_U_INT_16" ref="aea0f68c9e3c6885ffc3f443391306dd5" args="(LWES_U_INT_16 *anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_U_INT_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a39a07a14506fffb6a47cca57abfed182">LWES_U_INT_16</a> *&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a 16 bit unsigned int from a byte array. </p>
<p>Attempt to unmarshall anInt from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_U_INT_16 to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c413aff9b923f517ad0d6476b0935ac"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_INT_16" ref="a9c413aff9b923f517ad0d6476b0935ac" args="(LWES_INT_16 *anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_INT_16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a78b9045303595b0a80edf37fa6f7ac9d">LWES_INT_16</a> *&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a 16 bit int from a byte array. </p>
<p>Attempt to unmarshall anInt from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_INT_16 to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a423d499469ea32a8c683c1d1609e902e"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_U_INT_32" ref="a423d499469ea32a8c683c1d1609e902e" args="(LWES_U_INT_32 *anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_U_INT_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a0171d29ac3e49fea5a001037d67327a1">LWES_U_INT_32</a> *&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a 32 bit unsigned int from a byte array. </p>
<p>Attempt to unmarshall anInt from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_U_INT_32 to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="aedb853f7265bc58686a247b0472f88a9"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_INT_32" ref="aedb853f7265bc58686a247b0472f88a9" args="(LWES_INT_32 *anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_INT_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a08f39317c3e23633e355d49c1e68c656">LWES_INT_32</a> *&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a 32 bit int from a byte array. </p>
<p>Attempt to unmarshall anInt from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_INT_32 to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a8baecf644673e61dcdeb6ec4274b98dc"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_U_INT_64" ref="a8baecf644673e61dcdeb6ec4274b98dc" args="(LWES_U_INT_64 *anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_U_INT_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a7edcf94a675e9f0f0f68769b2d2badcd">LWES_U_INT_64</a> *&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a 64 bit unsigned int from a byte array. </p>
<p>Attempt to unmarshall anInt from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_U_INT_64 to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a145eeb7199a6987e1c8d250ebad8b0a8"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_INT_64" ref="a145eeb7199a6987e1c8d250ebad8b0a8" args="(LWES_INT_64 *anInt, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_INT_64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a136f66144ccf70b54e4bb00efafe9698">LWES_INT_64</a> *&nbsp;</td>
          <td class="paramname"> <em>anInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a 64 bit int from a byte array. </p>
<p>Attempt to unmarshall anInt from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>anInt</em>&nbsp;</td><td>the LWES_INT_64 to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a23199100ec118beb30bec07d3f098c55"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_BOOLEAN" ref="a23199100ec118beb30bec07d3f098c55" args="(LWES_BOOLEAN *aBoolean, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_BOOLEAN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a0c708659725468d2742864fee7f125cf">LWES_BOOLEAN</a> *&nbsp;</td>
          <td class="paramname"> <em>aBoolean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a boolean from a byte array. </p>
<p>Attempt to unmarshall aBoolean from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aBoolean</em>&nbsp;</td><td>the LWES_BOOLEAN to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="afcdee1b06232f1f3b3802d13dc6d6c36"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_IP_ADDR" ref="afcdee1b06232f1f3b3802d13dc6d6c36" args="(LWES_IP_ADDR *ipAddress, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_IP_ADDR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#afab73e182f5452ab18ceea7665fe7de5">LWES_IP_ADDR</a> *&nbsp;</td>
          <td class="paramname"> <em>ipAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall an ipv4 address from a byte array. </p>
<p>Attempt to unmarshall ipAddress from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>ipAddress</em>&nbsp;</td><td>the LWES_IP_ADDR to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a6971c3b3ae06c8fee8945f1bc2736f92"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_SHORT_STRING" ref="a6971c3b3ae06c8fee8945f1bc2736f92" args="(LWES_SHORT_STRING aString, size_t max_string_length, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_SHORT_STRING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#ab426e9825a40d378e7ffc13b5a7be906">LWES_SHORT_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>aString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_string_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a short string from a byte array. </p>
<p>Attempt to unmarshall aString from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The max_string_length is the maximum length of the passed in string.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aString</em>&nbsp;</td><td>the LWES_SHORT_STRING to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_string_length</em>&nbsp;</td><td>the total length of aString, this will not be overflowed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a51593ae7aaaed7ad63f5724dbe7aec6f"></a><!-- doxytag: member="lwes_marshall_functions.h::unmarshall_LONG_STRING" ref="a51593ae7aaaed7ad63f5724dbe7aec6f" args="(LWES_LONG_STRING aString, size_t max_string_length, LWES_BYTE_P bytes, size_t length, size_t *offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unmarshall_LONG_STRING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a74b6273817a2fd70c98c9c1bed431518">LWES_LONG_STRING</a>&nbsp;</td>
          <td class="paramname"> <em>aString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_string_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lwes__types_8h.html#a5f0398fc66cf488fcac017d5c9862ad5">LWES_BYTE_P</a>&nbsp;</td>
          <td class="paramname"> <em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmarshall a long string from a byte array. </p>
<p>Attempt to unmarshall aString from the given byte array at the given offset, without overflowing the bound. If the bound would be overflown, an error is returned.</p>
<p>The max_string_length is the maximum length of the passed in string.</p>
<p>The length should be the total length of the array.</p>
<p>The offset will be modified by the number of bytes consumed, and that value will be returned. Thus a value of 0 is an error, meaning not enough bytes to fill out the given type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>aString</em>&nbsp;</td><td>the LWES_LONG_STRING to read from the array and write into </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_string_length</em>&nbsp;</td><td>the total length of aString, this will not be overflowed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bytes</em>&nbsp;</td><td>the byte array to read from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>total length of the byte array </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset into the array, then the new offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on error, the number of bytes consumed on success. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 27 16:16:15 2012 for lwes by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
